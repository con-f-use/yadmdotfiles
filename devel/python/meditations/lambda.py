#!/usr/bin/env python
#coding=utf-8
"""
Lambda calculus as introduced by David Beazley in:

https://www.youtube.com/watch?v=pkCLMl0e_0k

Also note that lambda calclus has only single-argument functions.
Technically namings things, i.e. attaching symbols is not part of lambda
calculus.
"""

###############
# Boolean logic
###############

def TRUE(x): return lambda y: x
def FALSE(x): return lambda y: y
def AND(x): return lambda y: x(y)(x)
def OR(x): return lambda y: x(x)(y)
def NOT(x): return x(FALSE)(TRUE)

assert NOT(TRUE) is FALSE
assert NOT(FALSE) is TRUE
assert OR(FALSE)(TRUE) is TRUE
assert OR(TRUE)(FALSE) is TRUE
assert OR(FALSE)(FALSE) is FALSE
assert OR(TRUE)(TRUE) is TRUE
assert AND(FALSE)(TRUE) is FALSE
assert AND(TRUE)(FALSE) is FALSE
assert AND(FALSE)(FALSE) is FALSE
assert AND(TRUE)(TRUE) is TRUE

###########
# Numbers
###########

def incr(x): 
    """Just a sentinal for testing and visualization. Not allowed in lambda calculus."""
    return x+1

ZERO = lambda f: lambda x: x # = FALSE
ONE = lambda f: lambda x: f(x)
TWO = lambda f: lambda x: f(f(x))
THREE = lambda f: lambda x: f(f(f(x)))

assert THREE(incr)(0) is 3
assert TWO(THREE)(incr)(0) is 9  # 3 to the power of 2
assert THREE(lambda x: x+'*')('') == '*'*3

SCSR = lambda n: lambda f: lambda x: f(n(f)(x))

assert SCSR(ZERO)(incr)(0) is 1
assert SCSR(TWO)(incr)(0) is 3 
assert SCSR(SCSR(ONE))(incr)(0) is 3 

ADD = lambda x: lambda y: y(SCSR)(x)
MUL = lambda x: lambda y: lambda f: y(x(f))

assert ADD(ONE)(THREE)(incr)(0) is 4
assert MUL(TWO)(THREE)(incr)(0) is 6

# Notation in most papers:
# AND = lambda x: lambda y: x(y)(x) = λxy.xyx

# Argument substitution (beta reduction)
# (λxy.xyx)(ab) := (lambda x: lambda y: x(y)(x))(a(b)) = λy.(ab)y(ab)
# But no name clashes!:
#     (λxy.xyx)(y) => λy.yyy  # NOOO!!!
#     (λxz.xzx)(y) => λz.yzy  # YES, simple renaming without clases (alpha
#     conversion)

# eta convention:
# x = 3 same as x (lambda a: a)(3) = (λa.a)(3)

#################
# Data Structures
#################

def cons(a, b):
    """Idea from LISP:
    (cons 2,3) -> (2,3)    # this is a Tuple-analog
    (cons 2, (cons 3, 4))  # this is a linked list analog
    (car p) -> 2
    (cdr p) -> 3
    """
    def select(m):
        if m==0:
            return a
        elif m==1:
            return b
    return select

assert cons(2,3)(0) is 2
assert cons(2,3)(1) is 3

CONS = lambda a: lambda b: (lambda s: s(a)(b))
CAR = lambda p: p(TRUE)
CDR = lambda p: p(FALSE)

assert CONS(2)(3)(TRUE) is 2
assert CONS(2)(3)(FALSE) is 3
assert CAR(CONS(2)(3)) is 2
assert CDR(CONS(2)(3)) is 3

#############################################
# Reverse (decrement, precursor, predecessor)
#############################################

T = lambda p: CONS(SCSR(CAR(p)))(CAR(p))

a = THREE(T)(CONS(ZERO)(ZERO))
assert CAR(a)(incr)(0) is 3
assert CDR(a)(incr)(0) is 2

PRED = lambda n: CDR(n(T))(CONS(ZERO)(ZERO))
# Actually counts up to the number and then returns one value before it
# Can't relly go "earlier" than ZERO or what ever you induction anchor was

assert (PRED(THREE(TWO)))(incr)(0) is 8

SUB = lambda x: lambda y: y(PRED)(x)
FOUR = SCSR(THREE)

assert SUB(THREE)(FOUR)(incr)(0) is 3

ISZERO = lambda n: n(lambda f: FALSE)(TRUE)  # ONLY works on numbers, i.e. generated by ZERO and SCSR

assert ISZERO(ZERO) is TRUE
assert ISZERO(ONE) is FALSE 
assert ISZERO(THREE) is FALSE

FACT = lambda n: ISZERO(n)(ONE)(MUL(n)(FACT(PRED(n))))

# assert FACT(THREE)(incr)(0) is 6  # don't run this, will exceed max recursion
# depth because of eager evaluation n changes while same n is computed.

LAZY_TRUE = lambda x: lambda y: x()
LAZY_FALSE = lambda x: lambda y: y()
LAZY_ISZERO = lambda n: n(lambda f: LAZY_FALSE)(LAZY_TRUE)
LAZY_FACT = lambda n: LAZY_ISZERO(n)(ONE)(MUL(n)(LAZY_FACT(PRED(n))))

